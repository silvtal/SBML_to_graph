#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Mon Apr 26 12:12:15 2021

@author: silvtal
"""
from reframed import load_cbmodel
from reframed import Environment, CAFBA
from carveme.reconstruction.utils import load_media_db
import copy
import pandas as pd
import matplotlib.pyplot as plt
import networkx as nx

def create_spare_medium(f, medium, media_db, init_env=None, outputdir=".", outputname="tempmedium.tsv", include_original=True, to_remove=None, objective="Growth"):
    """ Spare medium creation. This function takes a given SBML model and simulates its growth on a given medium. Then returns a list of metabolites that are the "spent media", that is, the original media plus the model's secretions and without the nutrients that the model has fully consumed.
    
    Parameters
    ----------
    f : str
        model file name
    medium : str
             medium name in the media_db
    media_db : str
               .tsv file with the medium composition
    init_env : Environment, optional
               ReFramed-generated Environment object (default: None)
    outputdir : str, optional
                output directory for the spent media file (default: current working directory)
    include_original : bool, optional
                       whether to include original medium compounds on the output file, except those specified in to_remove (default: None)
    to_remove : list, optional
                list of compounds to remove from the original medium (default: None)
    objective : str, optional
                name of objective function (default: "Growth")
    """
    # load and solve the spent_model
    s_model = load_cbmodel(f,flavor="fbc2")   
    if init_env==None:
        init_env = Environment.from_compounds(media_db[medium])
    
    init_env.apply(s_model)
    solution = CAFBA(s_model)  
    
    # select all positive flux reactions
    df=solution.to_dataframe()
    positive_fluxes= df[df["value"]>0]
    
    # pick all exchange reactions except sinks
    my_r= [r for r in s_model.get_exchange_reactions() if "sink" not in r]
    
    spare=[r for r in list(positive_fluxes.index) if r in my_r]
    
    # get metabolites from those reactions
    my_m=["".join(r.split("_")[2:-1]) for r in spare]

    # create file
    if include_original:
        if to_remove==None:
            my_m= media_db[medium]+my_m
        else:
            medcopy=copy.copy(media_db[medium])
            for c in to_remove:
                medcopy.remove(c)
                my_m= medcopy+my_m
    
    temp_media=pd.DataFrame({
        "medium" : ["temp"]*len(my_m),
        "description" : ["spent medium without original"]*len(my_m),
        "compound" : my_m
        })
    
    temp_media.to_csv( outputdir+"/"+outputname,sep="\t")



def metabolite_translator(names_table):
    """
    Metabolite name translator
    
    Parameters
    ----------
    names_table : str
                  text file with BiGG ID-metabolite
    
    Returns
    -------
    dict
         keys are bigg IDs with one metabolite name as unique value
    """

    names_table = pd.read_csv(names_table, sep="\t")
    code_to_name = dict()
    for index, row in names_table.iterrows():
        pretty_name = str(row['name']).replace(" ","_")
        compartment = row['bigg_id'].split("_")[-1]
        code_to_name[row['bigg_id']]=pretty_name+"_"+compartment
                          
    return(code_to_name)
    

    
def reaction_parser(all_reac={}, weights={}, code_to_name=None,
                    exclude_reversible=False, 
                    exclude_irreversible=False, min_flux=0):   
    """
    Parses reactions to be included at the graphs generated by my_draw()

    Parameters
    ----------
    all_reac : dict
               reactions to be included in a graph
    weights : dict
              weights linked to each reaction (numeric values); values are usually fluxes
    code_to_name : dict
                   created by metabolite_translator

    exclude_reversible : bool, optional
                         whether to exclude reversible reactions from the graph (default: False)
    exclude_irreversible : bool, optional
                           whether to exclude reversible reactions from the graph (default: False)
    min_flux : float, optional
               minimum weight of reactions to be included (default: 0)
        
    Returns
    -------
    list
         adjacency list
    """ 
    adj_list=[]
    for reac in range(len(all_reac)): 
        r=str(all_reac[reac]).split(":")[1]
        flux=weights[list(weights.keys())[reac]]
        if abs(flux)<min_flux:
            continue # skip this iteration/reaction

        # parse (differs with reversibility)
        if "<->" in r and not exclude_reversible:
            s_and_p = r.split("<->")

            # arrow types
            if flux>0: 
                ar="-|>"
            elif flux<0:
                ar="<|-"
            else:
                print("The following reaction's weight is zero...? Something must be wrong with your filtering")
                print(reac)
                continue
        elif "-->" in r and not exclude_irreversible:
            ar="-|>"
            s_and_p = r.split("-->")
        else:
            continue # skip excluded reactions
            
        if len(s_and_p)>1: # only if the reaction has both substract and product
            try:    
                sust=[s.replace(" ","").split("M_",maxsplit=1)[1] for s in s_and_p[0].split("+")]
                prod=[p.replace(" ","").split("M_",maxsplit=1)[1] for p in s_and_p[1].split("+")]
                for j in range(len(prod)):
                    for i in range(len(sust)):
                        new_edge=str(code_to_name[sust[i]]+" "+code_to_name[prod[j]]+ # weight: flux's absolute value
                       " {'weight': "+str(flux)+
                       ", 'name':'"+ar+"'}")
                        adj_list.append(new_edge)
            except:
                print("Didn't know how to parse this: "+r)

    return(adj_list)



def my_draw(my_model, my_reactions, code_to_name, exi, exr, minf, my_figsize, fntsize, textrot):
    """
    Creates a graph. Calls reaction_parser.
    
    Parameters
    ----------
    my_model : CBModel 
               loaded with reframed.load_cbmodel
    my_reactions : dict
                   reactions and their weights. It comes directly from ReFramed's solution
                    example:
                    a = reframed_solution
                    my_reactions = {v:a.values[v] for v in a.values.keys()}
    code_to_name : dict 
                   created by metabolite_translator
    exi : bool
          whether to exclude or not irreversible functions from the graph
    exr : bool
          whether to exclude or not reversible functions from the graph
    minf : float
           minimum flux of reactions to be included in the graph
    my_figsize : tuple 
                 graph sizes (height and width)
    fntsize : int
              Font size for the labels
    textrot : float
              text rotation for the labels (degrees)
    """
    # Create a graph with reaction_parser and code_to_name
    ###############
    all_reac=[]
    for r in my_reactions.keys():
        all_reac.append(my_model.reactions[r])

    adj_list=reaction_parser(all_reac, weights=my_reactions, code_to_name=code_to_name,
                             exclude_irreversible=exi, exclude_reversible=exr, min_flux=minf)
    G = nx.parse_edgelist(adj_list, nodetype = str, data=True, create_using=nx.DiGraph)

    # layouts
    ##########
    G_4_layout = nx.parse_edgelist(adj_list, nodetype = str, data = True) 

    df = pd.DataFrame(index=G_4_layout.nodes(), columns=G_4_layout.nodes())
    for row, data in nx.shortest_path_length(G_4_layout):
        for col, dist in data.items():
            df.loc[row,col] = dist

    df = df.fillna(df.max().max())
    layout = nx.kamada_kawai_layout(G, dist=df.to_dict())

    pos=layout

    # draw
    # ====
    fig=plt.figure(figsize=my_figsize, dpi= 200, facecolor='w', edgecolor='k')

    nx.draw_networkx_nodes(G, pos,
                           node_color="lightgreen",
                           node_size=20)    

    text=nx.draw_networkx_labels(G, pos,font_size=fntsize,)
    for _,t in text.items():
        t.set_rotation(textrot)

    for edge in G.edges(data=True):
        ar = edge[2]['name']
        nx.draw_networkx_edges(G, pos,
                               node_size=20,
                               edgelist=[(edge[0],edge[1])],
                               arrowstyle=str(ar),
                               arrowsize=8,
                               width=0.4,
                               edge_color=plt.cm.cool(abs(edge[2]["weight"]))) # absolute weight = colour

    ax = plt.gca()
    ax.set_axis_off()
    plt.show()
